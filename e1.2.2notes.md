## 斐波那契数列的两种定义方式, 描述和过程

最开始因为书中讲的东西太过显然, 一下子看过去了

其实仔细想想, 求斐波那契数列的第n项的两种递归表示的代码其实含义有着巨大差异

第一种是对定义的直接翻译  
这段代码每次计算n-1和n-2项值之和时, 都会重新对第n-1项和n-2项分别求值  
这个叙述逻辑非常有普适性  
但是斐波那契数列有特殊性: 计算第n-2项时, n-2项的计算过程是n-1项计算过程的一颗子树

这也就是第二种代码优化的由来: 重复使用已经进行过的求值过程(使用结果, 而不真的重复计算)

当然这是从递归定义开始优化

实际上从斐波那契数列的自然语言描述: 从第三项开始, 每一项的值都是前两项之和
来看, 我们能很自然地认为斐波那契数列的计算复杂度是线性的, 从而也能从自然语言定义中引出第二段代码  

回到引出具有巨大差异的代码的两种定义本身

第一种定义是递归定义, 结合数学归纳法可以描述数列中的第n项, 但给出定义并不能描述数列的第n项值

第二种定义是自然语言定义, 它描述了一种根据前两项计算第三项的过程, 这种对过程的描述给出了第有限n项的值, 但不能将n扩展至正整数域

这是第1章第20条注释的一个非常好的例子——说明性描述(递归定义)和行动性描述(前两项之和)有着内在的联系  
但同时说明性的知识和行动性的知识之间也存在差异

遗憾的是, 了解到这一点并不能直接让我们能设计出更好的算法, 因为说明性的描述翻译出来的代码只是在暴算  
在数学中, 一条递归定义就已经说明了一切, 但对计算机这行不通

## 换钱

一开始看书上的说明 没仔细看也没看太看明白

我的第一反应是将问题按单个硬币进行划分, 然后根据硬币数量进行组合, 最终求出组合数  
经过简单尝试之后发现这种思路行不通  
原因在于不同面值的硬币并不总是相邻种类硬币的整数倍, 比如25美分和10美分硬币  
这种硬币的存在会导致存在跨上层面值硬币的划分  
比如2枚25美分的硬币一起换钱的组合, 并不是2个1枚25美分硬币换钱的组合  
可以简单举出反例: 1枚25美分硬币换钱最多只能有2枚10美分硬币参与, 但2枚25美分硬币换钱却能换到5枚10美分硬币

如果不同面值的硬币总是相邻面值硬币面值的整数倍, 那么可以转换为简单的组合问题

书中给出的说明则是这么个意思:  
我们有3个1美元硬币, 这3枚硬币换钱的组合数可以被划分成两种不同组分  
1. 3个1美元硬币全部换掉, 不保留1美元面值硬币的所有组合数
2. 2个1美元硬币的全部换钱组合数

这看起来有点违反直觉, 为什么我们的第2条划分依据是2个1美元硬币换钱的所有组合数, 而不是保留部分(在这个情景下则是保留1枚或2枚)1美元硬币的所有组合, 即如下划分
1. 3个1美元硬币全部换掉, 不保留1美元面值硬币的所有组合数
2. 2个1美元硬币全部换掉, 保留1枚1美元面值硬币的所有组合数
3. 1个1美元硬币换掉, 保留2枚1美元面值硬币的所有组合数

仔细列出条件之后我们会发现, 这里的第2,3条划分出的情况之和"恰好"是前面被划分出的第二种情况
当1美元硬币的数量上升到n时, 这种恰好也恰好成立

按部就班地列出分支条件, 再进行条件合并也是一种不错的方法, 哪怕看上去会绕点远路

如何才能直接得出如同书中说明般的结论呢?


我认为关键在于如何进行**子问题的划分**

在根据硬币的数量, 罗列不同数量硬币换钱的组合时, 我们划分问题的依据是根据表征的硬币数量  
这本身没有问题, 我们可以轻易地算出组合数量, 再乘上单个硬币的换钱组合, 然后按照硬币的种类递归下去就行了  
如果稍加观察, 也可以发现进行不同分类进行讨论的分支, 同样有着合并和简化的空间, 得出与书中相同的递归过程

而如果要直接得出与书中相同的递归过程, 则需要更好地进行子问题的划分  
我们一开始也做了子问题划分, 只是划分的结果没有那么精妙  
其间的差异在于: 精妙的子问题划分, 使得其中一个**子问题又变成了原问题**

回顾我最初的问题划分方式: 将n枚1美元硬币的换钱方式划分为不同数量1美元硬币的换钱组合数之和, 总共有n项
这种划分方式产生了n个子问题, 某些情况下(比如相邻面值为整数倍)我们可以组合1美元换钱来解决所有的子问题, 然而在这个问题下并不成立  
这种划分方式存在几个问题:
1. 粒度太细, 不够概括不够抽象, 没有提取出所有子问题的特征(当然如果适当合并分支就可以解决)
2. 没有构造出一个与原问题相同的问题

是不是如果足够聪明, 就可以直接划分出一个和原问题一致的子问题?  
对换钱这种简单问题来说, 也许是的, 但对于稍稍复杂的问题来说, 就不是那么回事了  
一个比较典型的例子就是, 求斐波那契数列的通项公式

以数列求和问题来说, 无论最终的计算是递归地还是迭代地, 我们都免不了去构造一些等式, 使得它总是同时满足n+1与n以及n与n-1之间的关系
在求斐波那契数列通项的时候, 我们也免不了用上待定系数法或者求线性变换矩阵的特征值, 才能构造出一个与原问题相同的子问题

在为复杂问题构造递归过程时, 知识和经验同样重要

此外, 更细粒度的问题划分, 有时候会更有助于优化

假设我们有4枚1美元的硬币  
按照上面的划分方式, 需要计算
1. 所有4枚1美元硬币全部换钱的组合数
2. 3枚1美元硬币(部分或全部)换钱的组合数

其中问题1会转变成: 求8枚0.5美元硬币换钱的组合数  
而问题2会划分出一个新的子问题: 3枚1美元硬币全部换钱的组合数, 进而转变为6枚0.5美元硬币换钱的组合数  
而8枚0.5美元硬币换钱组合数在经过两次递归计算后, 会产生出一个子问题: 6枚0.5美元硬币换钱的组合数  

由此, 会产生若干次重复的计算

优化方式很容易能想到几种  
一种是书上提起的缓存已经计算过的结果  
另一种是针对0.25美元币值的硬币换钱组合做特殊处理, 其余情况则是单个硬币换钱的组合数乘以硬币数量
另一种, 很显然这是一个组合数学问题

考虑一个更为一般的问题
对满足等式S = ∑Di*Ni的所有Ni求出组合数量  
其中Di和S都是已知常量  

尝试了一下移项然后利用正整数条件构造不等式, 但是没看出什么东西, 印象中这是个解决方案, 但也仅仅是印象了  
此间偶然发现这个问题很容易写成  
S为n维已知向量D和未知向量N的标量积, 其中向量D,N的分量为正整数(为0时不对结果造成影响, 因此省略)  
求可能的向量N的数量

问题看上去开始变得非常简单(至少几何意义容易直观理解)  
要做的事情变成了, 在任意可数n维空间中, 求N的分量为正整数时, N在D上投影为S的所有可能情况的数量

遗憾的是我所受的数学教育不足以支撑对四维及以上空间的几何想想  
为了便于理解, 先考虑3维的情况
我们有向量D(d1, d2, d3)和投影S, 令k*D·D=S, 可以得到k的值  
于是我们得到了一个过kD点且垂直于D的平面, 同时也是一个平面点集  
当然这个点集的方程满足d1*x+d2*y+d3*z=S
这个平面点集是个无穷集, 但正整数的条件将集合缩小, 限定在第一卦限的有限点集上

对任意可数n维空间来说, 这也同样成立

遗憾的是要在这样一个只有单个方程描述的平面上找出所有满足条件的点集也不是一件容易的事  
但这种能用自然语言简单表述的几何问题, 很可能已经被解决了

---

感觉在数学问题上花了太多时间, 不管是书中的例子还是习题

进度有点太慢了

还是应该把重心放在书本身的内容上

之后开始阅读进度优先, 然后延迟几天再通过习题复习