#lang scheme

;;; exercise 2.16 ;;;

#|
从2.15中的测试来看, par2获得的区间范围始终小于par1

为什么会出现这种现象?
在练习2.14中我猜测是因为乘法除法所得区间的上下界取值会由于区间本身的差异而有所不同  
所得区间边界无法通过原有的两个区间边界用代数式表达(练习2.9)  
这可能导致不同的计算过程下, 所得到的区间有所差异  
但是没有仔细去推导是否真的是因为这个原因  

这里尝试一下打印出中间结果
以
(define A (make-center-percent 100 0.01))
(display (par1 A A))
(display (par2 A A))
为例
par1的最后一步是
(9998.0001 . 10002.000100000001) / (199.98 . 200.02) = (49.98500199980001 . 50.01500200020003)
par2的最后一步是
(1 1) / (0.01999800019998 . 0.020002000200020003) = (49.995 . 50.005)
如果分子分母的区间都扩大10000倍
得(10000 10000) / (199.9800019998 . 200.02000200020003) = (49.995 . 50.005)
这个等于是通过
(define X1 (make-interval 10000 10000))
(define X2 (make-interval 199.9800019998 200.02000200020003))
(div-interval X1 X2)
计算所得
这使得区间范围没有进一步被扩大
|#

#|
问题1的回答: 
代数表达式等价并不代表计算过程等价, 不同的计算过程下区间范围会被放缩, 进而产生差异
|#

#|
首先可以肯定的是, 计算包被调用时的计算过程是无法统一的
除非有一个计算过程标准化的过程, 使得等价的计算过程统一起来, 也就是说将整个计算过程作为一个输入
得到一个新的统一的化简后的计算过程
考虑式 Π(aix^t1i + biy^t2i)^ni, 展开后可以有任意项的x和y的任意次幂, 显然是无法化简的(但难以证明)
就算把计算过程限定在加减乘除范围内, 并且不考虑区间和实数的混合运算, 只考虑区间之间的计算  
每个原子区间计算过程还是无法获取其他原子计算的信息

如果只提供区间四则运算的原子计算过程, 感觉是做不到这件事的
但如果允许将整个计算过程进行优化, 那么是有可能的
因为由直觉可知, 这种情景下一系列四则运算总是能写作两个二元整次多项式相除的形式(虽然区间范围会变大)
|#

#|
网上找了下答案
https://billthelizard.blogspot.com/2010/12/sicp-212-216-extended-exercise-interval.html
https://en.wikipedia.org/wiki/Interval_arithmetic#Dependency_problem

http://community.schemewiki.org/?sicp-ex-2.16
For really complicated systems, we could also perform Monte carlo simulations to get an answer that is good enough
这里提到针对现实世界的复杂问题, 可以采用蒙特卡洛方法
此外还提到了先对中点进行算数运算, 再对偏移量进行计算, 但不知道这种方法是不是能够保证不同计算过程中能得到一致的结果
|#