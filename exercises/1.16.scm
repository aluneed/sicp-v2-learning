#lang scheme

;;; exercise 1.16 ;;;

#|
先反思一下书中给出的fast-expt
b^n = b * b^(n-1)
这种变换非常简单粗暴, 我们可以轻易构造出指数为n = 2^a - 1这样的情况来
此时如果n=127, 那么迭代之后的n=126/2=63=2^(a-1) + 1

这也就是迭代计算过程的难点所在, 我们无法直接得到迭代的次数

但同时也很容易发现, 应该将n分成2的整次幂, 以及其余部分
虽然看不太懂书上的提示
但是发现这一点后, 很容易猜到以b为底, 以这个2的整次幂为指数的值的累乘就是a

根据提示, 我们设法构造出一个函数
(iterator a b n)
这个函数得到a*b^n的值
每次迭代, 我们找出b^n中, 小于n的2的整次幂的部分
然后把它乘到a中得到a', 再从b^n中拿走这一部分, 得到新的n'
|#

(define (itrFastExpt b n) (
    iterator 1 b n
))
(define (iterator a b n) (  ;;init a = 1
    cond
        ((= n 1) (* a b))
        ((= n 0) a)
        (else (iterator (* a (uniqueExpt b (log (cut n 1) 2))) b (- n (cut n 1))))  ;;(iterator a' b n')
        ;;在这里可以考虑通过(iterator 1 b (cut n 1))来取代(uniqueExpt b (log (cut n 1) 2)), 但这样会导致递归计算过程
))

;;指数是2的整次幂时的快速计算, b为底数, n为2的整次幂的次数
(define (uniqueExpt b n) (
    if (= n 0)
        b
        (uniqueExpt (* b b) (- n 1))
))
#|todo
(define (recUniqueExpt b n) (
))|#


;;我们需要拿到不大于n的2的整次幂
(define (cut n ax) (  ;;init ax = 1
    if (> ax n)
        (/ ax 2)
        (cut n (* 2 ax))
))
(define (recCut n) (
    cond
        ((= n 1) 1)
        ((> (* 2 (recCut (quotient n 2))) n) (recCut (quotient n 2)))
        (else (* 2 (recCut (quotient n 2))))
))
#|
完全不同的两种写法
迭代计算过程十分简单, 我们要做的就是从1开始构造一个小于n的2的整次幂
递归计算过程则是在递归过程中得到了2的指数, 然后在回调的时候将值计算出来, 虽然计算过程是递归的, 但物理意义是迭代的

实际上我们在对n进行拆分的时候, 就可以调用(iterator 1 2 bx)对bx进行穷举
然后得到一个不大于n的值ax = (iterator 1 2 bx), 再继续用二分法对bx进行快速优化(bx必然小于(log n 2), 大于0)
这种对迭代的参数不断进行二分优化的过程, 会使我想起联系1.10中的阿克曼函数x=3时的特例
如果每一个迭代过程都采用二分法进行优化, 那么步数增长的阶为反阿克曼函数

由于n已经是一个指数, 不会太大, 因此暂时不对ax|ax<n的求值过程进行优化
上面在计算(cut n)得到一个2的整次幂后, 对这个整次幂求了以2为底的对数, 然后又通过一个特殊的函数去计算指数, 可以优化掉这一步 
|#

#|

新的发现

递归计算过程和迭代计算过程的一个显著差异就是
函数是否在求值表达式中直接或间接地引用了自身(自指)

在上面的函数中, iterator显然调用了自身, 毫无疑问, 这是一个递归过程
但涉及到计算过程, 则与求值顺序会有所关联
在上面写出的迭代计算过程中
(iterator ...)经过if的求值之后, 又变成了一个新的(iterator ...)表达式
并且这个新的表达式, 进一步求值的结果, 要么是与iterator无关的表达式, 要么是一个更新的(iterator ...)

但如果代码中某个地方的求值结果变成了(iterator (f (iterator ...) ...)), 其中(f ...)是一个用到了(iterator ...)所得值的过程
那么就会产生自指, 于是整个(iterator (f (iterator ...) ...))不得不先对(iterator ...)进行求值
最后在得到求值结果后, 在进一步对(f ...)进行求值, 最后再对外层的(iterator ...)求值

如果将函数看成算子
那么f(f(f(...f(x)))) = f^n(x)这个递归过程在scheme中会变成一个迭代计算过程(在其他语言中未必, 因为会不断地return到上层)
这是因为f(f(x))=f(x'), 在函数中做好x'=f(x)的变换即可, 这也就是练习提示中的状态变量a的变换
在变换完成后, 求值的结果就是f(x')
但f(g(f(x)))=f(x'), x'=g(f(x)), 求值的结果是g(f(x)), 于是只能继续对f(x)求值, 产生了递归计算过程
简记之后为(f·g)^n(x)
不知道lambda算子是否和函数f的变换有关

此外, 练习1.5和1.6也变成了一种伏笔, 因为迭代计算过程和求值顺序有很大的关联

|#

#|
看了下别人的答案
https://codology.net/post/sicp-solution-exercise-1-16/

(define (fast-expt-iter a b n)
  (cond ((= n 0)
         a)
        ((even? n)
         (fast-expt-iter a (* b b) (/ n 2)))
        (else
         (fast-expt-iter (* a b) b (- n 1)))))

这里直接通过n来控制迭代次数以及迭代时的计算方式
我把控制的过程分离成了特殊的指数计算过程, 并将结果存在a中
而在(recCut n)中, 如果不返回结果, 则这个递归过程等同于答案中的代码

差异点在于, 我在同样的过程中得到(cut n)的结果后, 通过这个结果去控制迭代中的计算
奇偶的判断则被推迟到了最后关于n=0或1的判断中
同时uniqueExpt虽然很快, 但是会产生冗余的重复计算(比如计算了3^4时已经计算了3^2, 但在后续又会进行重复计算)

以3^63为例
我的计算过程是
3^32*3^16*3^8*3^4*3^2*3^1
而答案中代码的计算过程则是(fast-expt-iter 1 3 63)
3*(fast-expt-iter 1 3 62)
3*(fast-expt-iter 1 3^2 31)
3*3^2*(fast-expt-iter 1 3^2 30)
3*3^2*(fast-expt-iter 1 3^4 15)
3*3^2*3^4*(fast-expt-iter 1 3^4 14)

可以看出, 我的迭代次数比答案要少, 因为奇偶判断被推迟到了最后一步
但是每次迭代的开销都要大得多
答案中的每次迭代都引用了上一次计算的结果, 因此无需重复计算指数较小时的幂值

对指数n的拆分也有所不同
我的拆分是n=∑ki2^i
而答案的拆分方式是n=(((((((b)*2+1)*2+1)...)*2)*2+1)*2+1)
写成指数形式就是
b^n
=b*b^(n-1)
=b*(b^((n-1)/2))^2 = b*(b^2)^((n-1)/2)
=b*(b^((n-1)/2-1)*b)^2
=b*b^2*(b^((n-1)/2-1))^2
也就是说对函数而言, 底数b本身也是一个变动的值, 用来存储/传递之前的计算结果
这就是题目中提示的等式关系

|#