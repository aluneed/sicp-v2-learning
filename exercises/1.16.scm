#lang scheme

;;; exercise 1.16 ;;;

#|
先反思一下书中给出的fast-expt
b^n = b * b^(n-1)
这种变换非常简单粗暴, 我们可以轻易构造出指数为n = 2^a - 1这样的情况来
此时如果n=127, 那么迭代之后的n=126/2=63=2^(a-1) + 1

这也就是迭代计算过程的难点所在, 我们无法直接得到迭代的次数

但同时也很容易发现, 应该将n分成2的整次幂, 以及其余部分
虽然看不太懂书上的提示
但是发现这一点后, 很容易猜到以b为底, 以这个2的整次幂为指数的值的累乘就是a

根据提示, 我们设法构造出一个函数
(iterator a b n)
这个函数得到a*b^n的值
每次迭代, 我们找出b^n中, 小于n的2的整次幂的部分
然后把它乘到a中得到a', 再从b^n中拿走这一部分, 得到新的n'
|#

(define (itrFastExpt b n) (
    iterator 1 b n
))
(define (iterator a b n) (  ;;init a = 1
    cond
        ((= n 1) (* a b))
        ((= n 0) a)
        (else (iterator (* a (uniqueExpt b (log (cut n 1) 2))) b (- n (cut n 1))))  ;;(iterator a' b n')
        ;;在这里可以考虑通过(iterator 1 b (cut n 1))来取代(uniqueExpt b (log (cut n 1) 2)), 但这样会导致递归计算过程
))

;;指数是2的整次幂时的快速计算, b为底数, n为2的整次幂的次数
(define (uniqueExpt b n) (
    if (= n 0)
        b
        (uniqueExpt (* b b) (- n 1))
))
#|todo
(define (recUniqueExpt b n) (
))|#


;;我们需要拿到不大于n的2的整次幂
(define (cut n ax) (  ;;init ax = 1
    if (> ax n)
        (/ ax 2)
        (cut n (* 2 ax))
))
(define (recCut n) (
    cond
        ((= n 1) 1)
        ((> (* 2 (recCut (quotient n 2))) n) (recCut (quotient n 2)))
        (else (* 2 (recCut (quotient n 2))))
))
#|
完全不同的两种写法
迭代计算过程十分简单, 我们要做的就是从1开始构造一个小于n的2的整次幂
递归计算过程则是在递归过程中得到了2的指数, 然后在回调的时候将值计算出来, 虽然计算过程是递归的, 但物理意义是迭代的

实际上我们在对n进行拆分的时候, 就可以调用(iterator 1 2 bx)对bx进行穷举
然后得到一个不大于n的值ax = (iterator 1 2 bx), 再继续用二分法对bx进行快速优化(bx必然小于(log n 2), 大于0)
这种对迭代的参数不断进行二分优化的过程, 会使我想起联系1.10中的阿克曼函数x=3时的特例
如果每一个迭代过程都采用二分法进行优化, 那么步数增长的阶为反阿克曼函数

由于n已经是一个指数, 不会太大, 因此暂时不对ax|ax<n的求值过程进行优化
上面在计算(cut n)得到一个2的整次幂后, 对这个整次幂求了以2为底的对数, 然后又通过一个特殊的函数去计算指数, 可以优化掉这一步 
|#

#|

新的发现

递归计算过程和迭代计算过程的一个显著差异就是
函数是否在求值表达式中直接或间接地引用了自身(自指)

在上面的函数中, iterator显然调用了自身, 毫无疑问, 这是一个递归过程
但涉及到计算过程, 则与求值顺序会有所关联
在上面写出的迭代计算过程中
(iterator ...)经过if的求值之后, 又变成了一个新的(iterator ...)表达式
并且这个新的表达式, 进一步求值的结果, 要么是与iterator无关的表达式, 要么是一个更新的(iterator ...)

但如果代码中某个地方的求值结果变成了(iterator (f (iterator ...) ...)), 其中(f ...)是一个用到了(iterator ...)所得值的过程
那么就会产生自指, 于是整个(iterator (f (iterator ...) ...))不得不先对(iterator ...)进行求值
最后在得到求值结果后, 在进一步对(f ...)进行求值, 最后再对外层的(iterator ...)求值

如果将函数看成算子
那么f(f(f(...f(x)))) = f^n(x)这个递归过程在scheme中会变成一个迭代计算过程(在其他语言中未必, 因为会不断地return到上层)
这是因为f(f(x))=f(x'), 在函数中做好x'=f(x)的变换即可, 这也就是练习提示中的状态变量a的变换
在变换完成后, 求值的结果就是f(x')
但f(g(f(x)))=f(x'), x'=g(f(x)), 求值的结果是g(f(x)), 于是只能继续对f(x)求值, 产生了递归计算过程
简记之后为(f·g)^n(x)
不知道lambda算子是否和函数f的变换有关

此外, 练习1.5和1.6也变成了一种伏笔, 因为迭代计算过程和求值顺序有很大的关联

|#