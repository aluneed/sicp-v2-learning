#lang scheme

;;; exercise 1.26 ;;;

#|
我的环境中压根就没有square函数
所以我在e1.2.6笔记的iterator中用(expt n 2)进行计算

假设有
(define (square x) (* x x))
那么在调用(square (expmod ...))时, 会立即对(expmod ...)的部分求值
得到所得值x
然后对(square x)进行求值
(expmod ...)只会计算一次

假设原始(expmod ...)的步数增长阶为O(log n), 
这是因为每一次调用算作一步, 被调用的次数为(log n 2), 这个次数等同于n被二分至值为1时经历的次数, 本质上为1步重复(lnn/ln2)次
那么对每一层调用的步长都翻倍后, 步数为2步, 并且每一步之内的步数也会发生变化, 因此步数为2^(lnn/lnn2)=n步

第一反应是变为(logn)^2, 实际上还需要考虑到每一步内的细节, 步长都变成了2倍
更为精确的计算是
t'=2t+C, 迭代(lnn/lnn2)次, 即T = 2^(lnn/lnn2) + 2^(lnn/lnn2 - 1)C + ... + C
之前的则是t'=t+C, 迭代(lnn/lnn2)次, 于是T = t0 + (lnn/lnn2)*C

由于这个差异, 导致了两者保留的项不同, 一个是乘数项, 一个是指数项
|#

