#lang scheme

;;; exercise 1.19 ;;;

#|
斐波那契数列的通项式是两个指数项之差, 当然可以通过fast-expt在对数步数中算出来

更加直白一点的方式是
Fib(n)=0,1,1,2,3,5,...
Fib(n)=A(n)
A(n)=A(n-1)+A(n-2)
    =2A(n-2)+A(n-3)
    =3A(n-3)+2A(n-4)
    =5A(n-4)+3A(n-5)
    ...
    =Fib(i)A(n+2-i)+Fib(i-1)A(n+1-i)

满足i=n+2-i, i-1=n+1-i时
i=(n+2)/2=n/2+1
此时
Fib(n)=Fib(n/2+1)^2 + Fib(n/2)^2

这个式子其实在1.13中尝试推导数列通项的时候就写出来了, 当时还没有用待定系数法
对计算过程来说, 这个式子很有优势, 但是对求通项公式来说却没什么价值
通过这个式子仍然可以构造出步数为对数增长速率的求值过程
但仍然会有重复计算, 并且也没有题目中给出的变换方法得到的过程来得简单

题目中的变换实际上和网上能查到的一些线性变换是一个东西
a''=b'q+a'q+a'p
b''=b'p+a'q
a'=bq+aq+ap
b'=bp+aq
a''=q(bp+aq)+q(bq+aq+ap)+p(bq+aq+ap)
   =a(2q^2+2pq+p^2)+b(2pq+q^2)
b''=p(bp+aq)+q(bq+aq+ap)
   =a(q^2+2pq)+b(p^2+q^2)
得
p'=p^2+q^2
q'=q^2+2pq
斐波那契数列的每第n+1,n项数对, 都由变换(Fib(n+1),Fib(n))=Tpq^n(Fib(1),Fib(0))得到
但如果我们有了变换Tp'q', 使得该变换每进行一次等同于斐波那契数列迭代三次
也就是上面的Tpq变换进行两次
于是斐波那契的每第n+1,n项数对, 可以由变换
(Fib(n+1),Fib(n))=Tp'q'^(n/2)(Fib(1),Fib(0))得到
当然此时需要n为偶数
在此后, 斐波那契数列的第n+1,n项数对与某个随n递增1按Tp'q'变换两次的数列在n/2处得到的数对相等
于是斐波那契数列求第n+1,n项数对的问题转变为求这个新的数列在n/2处的数对的问题
同时这个新的数列的变换形式, 仍然满足a<-bq+aq+ap, b<-bp+aq
同时n/2或n/2-1为偶数时, 还可以从这个数列中构造出一个新的数列

当然代码中需要填上的分别就是
(+ (* p p) (* q q))
(+ (* q q) (* 2 p q))

我觉得整个题目的难点在于构造出Tpq为a<-bq+aq+ap, b<-bp+aq的变换族
如果没有题目提示很难想出来这个变化
我应该去复习一下线性代数

|#

(define (fib n) (fibIter 1 0 0 1 n))

(define (fibIter a b p q count) (
    cond
        ((= count 0) b)
        ((even? count) (
            fibIter
                a
                b
                (+ (* p p) (* q q))
                (+ (* q q) (* 2 p q))
                (/ count 2)
        ))
        (else (
            fibIter
                (+ (* b q) (* a q) (* a p))
                (+ (* b p) (* a q))
                p
                q
                (- count 1)
        ))
))
