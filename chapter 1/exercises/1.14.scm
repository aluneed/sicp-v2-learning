#lang scheme

;;; exercise 1.14 ;;;

#|

数值上的组合分支

11
(10*1) | (1*1)
(5*2)
(5*1) | (5*1)
(1*5) | (1*5)
(1*4) | (1*1) || (1*4) | (1*1)
...

|#

#|

增长的阶

之前我决定优先阅读, 然后隔几天再做习题
但是我发现书的内容和习题联系十分紧密, 并且习题也占了相当部分的篇幅, 因此还是不得不按照阅读进度来进行联系
另外虽然打算减少在数学上花费的时间, 但对这道题来说, 从代数出发比从一颗乱七八糟的树出发要简单得多

在e1.2.2notes.md中的笔记中就已经提到, 换钱问题可以归约为

对满足等式S = ∑Di*Ni的所有Ni求出组合数量  
其中Di和S都是已知常量  
并且他们都是正整数


对任意Na, 我们都有
Da*Na = S - ∑Di*Ni|i!=a < S
Na < S/Da

这个不等式在尝试通过代数方法去求解问题的时候就很容易发现
再结合正整数条件, 我们可以很容易地知道Ni可以取遍满足S/Di的正整数
遗憾的是, 由于Ni之间存在线性约束条件, 我们无法直接由此得出结论

然而到了这里, 这个不等式派上了用场

在我们通过递归过程遍历了满足等式的所有组合后, 每一个Ni构成的组合都被至少访问过一次
而最大的问题是, 我们需要知道每个组合最多被访问过多少次
理想情况下, 每个Ni的组合被访问的最大次数应当是和i的总数n线性相关的(我开始后悔用Ni来表示Di对应的数量了)
不太理想的情况下, Ni组合被访问的次数是和i的总数n的一个常数幂相关的

不太可能的情况是, Ni组合被指数级地大量访问, 因为这个算法并没有像ackermann函数那样, 在一个返回值中嵌套地调用它自身
这是从我们对一个函数的直觉出发的, 从另一个角度出发, Ni的组合数实际上也没有达到和n的指数线性相关的程度

当然实际弄清楚这个算法对Ni组合的访问是如何进行的之后, 这些问题变得不那么重要

每一个Ni构成的组合都被至少访问过一次
这种“至少”可能看上去并不显然
实际上Ni的每一种组合都和这个树状图展开过程中的每个状态一一对应
我们假设树中的每个节点都有一个包含着若干Ni组合的集合, 并且Ni组合满足∑Di*Ni的值为这个节点的金额总数
不难理解, 我们在每个节点得到的值都是这个集合的元素数量
树中的节点总是被分为互补的两种情况讨论, 每种情况总是相对于当前节点的所有组合互为补集
因此每个节点只和它的直系亲属有包含关系, 并且总是和它的兄弟节点或者别的什么远房亲戚交集为空
这完全得益于算法对问题的良好分解, 兄弟节点的集合总是没有交集, 完全独立, 并集又等于它们父节点的集合

它们看起来就像这样
[                ]
[        ][      ]
[    ][  ][  ][  ]
[  ][][][][][][][]
[][]

在最开始考虑换钱问题的性能损耗时, 就很容易发现递归计算过程中存在重复计算
但这对于实实在在的硬币来说是有意义的, 因为每次重复计算都对不同的硬币进行
这些计算看上去重复则是因为这些硬币有时有着相等的面额(或者同属一个Ni组合集合)

虽然没有给出严格证明, 但我们大概能知道, 每个Ni组合和树节点的数量是线性相关的
当我们拥有一个组合向量N时
如果其中一个分量Ni可以进行线性变换(在书上提供的算法中, 我们总是能将一枚高面值的硬币线性变换为低面值硬币的组合)
我们总能得到两个互补的线性变换所得的向量N的集合, 并且能通过这种方式不断划分下去

最终, 当节点不能划分时, 我们得到了一个只有一种Ni组合的集合, 访问到了这个Ni组合
虽然不能严格证明, 但组合数量线性相关于叶子节点的数量(我甚至不太确定这个结论是否正确)

遗憾的是, 经过一系列努力, 我们没有得出任何关于步数的增长的阶相关的直接结论

但组合数量线性相关于叶子节点数量C, 以及金额S
观察上面那个像树一样的集合, 并结合两节点总是互补的条件和算法本身
不难发现, 如果一个节点只有一个Ni的组合, 那么这个子节点必然是叶子节点
考虑一些极端情况
[      ]
[    ][]
[  ][]  
[][]
可以发现, 对这样一颗满二叉树, 叶子节点数量总是和节点总数线性相关

这个时候才会用到前面的不等式, 我们遍历了复合条件的Ni组合的所有情况所得的组合数量C, 满足
C < ∏Na = ∏((S - ∑Di*Ni|i!=a)/Da) < ∏(S/Di) = S^n/(∏Di)
其中n是Di的数量, 而S恰好是衡量我们现金量的标准
虽然脚标已经完全混乱了, 但是大致意思就是这样

整理之后得到
C < S^n/(∏Di), 同时C线性相关于节点数量, 并且节点数量线性相关于递归调用次数

对5类硬币的情况来说, 步数增长阶为theta(n^5), 当然实际上常系数影响大到不应当忽视

复盘一下, 这么大的篇幅其实主要目的在于:
1. 说明叶子节点数量和组合数量的线性相关性
2. 说明这个算法的递归过程是一颗满二叉树, 进而说明步数与叶子节点数的关系, 进而说明步数与组合数的关系
3. 最终通过组合数和所有Ni可能组合数的不等关系, 进一步放缩, 最终得到一个和单一变量金额S有关的不等式

空间增长阶正比于最大栈深d
最大栈深d则取决于如何划分当前的金额S, 在这个满二叉树中, d介于S与log(2,S)之间
因此空间增长阶为theta(n), n和金额S一致

|#
